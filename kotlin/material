- - - - - - - - - - - - INTRODUCTION - - - - - - - - - - - - -

- here are few links to learn about kotlin
--> https://kotlinlang.org/docs/home.html
--> https://developer.android.com/kotlin/style-guide
- functions are declared with the fun keyword
- println prints on another line, print keeps printing on the same line
- comments are similar to java: with // or /*
- Kotlin doesn't use semocolons! 


- - - - - - - - - - - - DATA TYPES AND VARIABLES - - - - - - - - - - - - -

- kotlin supports ints, strings, booleans, chars
- a variable is defined a bit differently                                                               --> var dogName: String = "Lucifer"
- you dont have to initialize the value at once, it can be done later by                                --> dogName = "Lucifer"
- if you want an immutable variable, just replace var with val
- you can use variable inference(when you don't specify the type) and the compiler will guess it

- print("${typeTest::class.simpleName}") --> will return the type of the value 
- an emoji is a string consisting of unicode characters
- concatenating strings is done the same way as in java, with a plus notation
- you can also use templates                                                                             --> Template: "Hello, $variableName!"
- if you want to use an input, readline is the function for that                                         --> val myColor = readLine()

- kotlin has various number types that have different sizes. For example, long, int, double, short
- kotlin supports all of the basic arithmetic operations
- the math libary contains some more complex mathematical equations (pow, min, random, round)



- - - - - - - - - - - - CONDITIONALS - - - - - - - - - - - - -

- IF:
if (raining) {
  println("Bring an umbrella.") 
} else{
  println("put on a dress")  }

- kotlin has all the generic logical operations
- you can nest conditional statements 

if (sailColor == "red") {
  println("Follow the lower river.")
  if (sailPattern == "striped") {
    println("Then take the right path.")
  }
  
 - WHEN :
when (letter) {                                                        //specifying the compared variable
  in 'a'..'m' -> println("Letter is in 1st half of alphabet.")         // .. is used to declare a range (here between a and m)
  in 'n'..'z' -> println("Letter is in 2nd half of alphabet.")         // in is used to check if something is in a list
  else -> println("Not a valid value")
}


- - - - - - - - - - - - COLLECTIONS - - - - - - - - - - - - -

- - - - - LISTS
- Creating a list --> var/val listName = listOf(value1, value2, value3)
- listOf creates an immutable list, with var you can make the variable contain another list, but the content cannot change
- you can access the list's elements by their index --> listName[0]
- Creating a mutable list --> var/val listName = mutableListOf(value1, value2, value3) 
- now you can change, remove and add elements to the list
- .size returns the number of elements in a list
- kotlin, like other languages has built-in functions. One is .random that returns a random element of a list
- .contains() you can check if a list has a specific element
- .add() adds an element and .remove() deletes one

- - - - - SETS
- creating an immutable set --> var setName = setOf(val1, val2, val3)
- sets are unordered, but they are stored in the order the elements were initialized 
- you can access an element by -->  listName.elementAt(integer) 
- creating a mutable set --> var/val setName = mutableSetOf(value1, value2, value3)
- in addition to add and remove, you can use addAll and Clear functions that will concern all of the elements
- A empty set is created like this --> var uniqueParticipants = mutableSetOf<String>()
- a few other built-in functions are .first(), .second() and .sum()
- in sets there can be only one of each value

- - - - - MAPS
- maps are like objects with key-value pairs in javascript
- creating an immutable map --> al/var mapName = mapOf(key1 to val1, key2 to val2, key3 to val3)
- you can access a value by mapName["keyName"] 
- if you want all keys or all values, use .keys and .values
- creating a mutable map --> var/val mapName = mutableMapOf(key1 to val1, key2 to val2, key3 to val2)
- you can reassign the values --> students["Willow"] = 16 
- keys cannot change
- Adding a value --> nationalTrees.put("Albania", "Olive") 
- removing a value --> nationalTrees.remove("Canada")



- - - - - - - - - - - - LOOPS  - - - - - - - - - - - - -

FOR LOOP 
var num = 4
for (i in 1..num) {
  println("i = $i")
}

- for (i in 4 downTo 1)                // will count from 4 to 1
- for (i in 1 until 4)                 // will count from 1 to 3
- for (i in 1..8 step 2)               // prints 1, 3, 5, 8

-iterating through a list or a set 
for (fruit in fruitList) {
  println("I have $fruit.") }
  
for ((listIndex, fruit) in fruitList.withIndex())           //this will return the item and its index
for (setIndex in fruitSet.indices)                          // here only the index will be returned
 
 ITERATING THROUGH MAPS
for ((itemName, itemCount) in myClothes) {
  println("I have $itemCount $itemName")  }                // this returns keys and values, first parameter is the key and second the value
for (itemName in myClothes.keys) {                         //here is how you can go only through the keys (values work simirarly)

- kotlin also supports while loops, which are similar to javas
- when breaking from nested loops, we need labeled jump expressions
val game = listOf("Rock", "Paper", "Scissor")
 
rps@ for (p1 in game) {
  for (p2 in game) {
    if (p1 == "Paper") {
      break@rps                                            // breaks out from the outer loop
    }
    println("$p1 vs. $p2") } } 
    
    
    
- - - - - - - - - - - - FUNCTION - - - - - - - - - - - - -

- fun getSpeed(distance: Int, time: Int) {               // here we have given the funtion two variables
- you can assign a function to a variable so you can get the result by calling the variable
- a single expression function can be made to shorten your expression

fun powerOf2(num: Int): Int {               -->             fun powerOf2(num: Int) = num * num
  return num * num }
 
- a function literal is an unnamed function that behaves like any variable would
- there are two types of function literals: anonymous functions and lambda expressions

- Anonymous:                                                       Lambda:
val quotient = fun(num1: Int, num2: Int): Double {                  val quotient = { num1: Int, 
  return num1 / num2 }                                              num2: Int -> num1 / num2 }
  
  
  - - - - - - - - - - - - CLASSES - - - - - - - - - - - - -
  
  - you can create an instance of the calss --> val myCar = Car()   //myCar is the name, car is the class's name
  - then you can call the instances properties --> println(myCar.color)
  - a primary constructor allows you to declare properties and initialize them when calling the object
  
  - class Car(val year: Int, val model: String, val color: String)
  --> val myCar = Car(2011, "Jeep", "Blue") 
      val friendsCar = Car(2015, "Mazda", "Red")  //the instances get their own unique properties
      
 - you can create an init block to add more logic to your class
 - the method will run everytime you call the instance
 
 class Mascot(val name: String, val platform: String, val yearCreated: Int) {
  var age: Int
 
  init {
    age = 2020 - yearCreated
    println("$name is a $platform mascot and is $age years old. ") } }
  



